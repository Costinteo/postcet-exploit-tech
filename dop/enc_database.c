#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef struct {
	char password[64];
	char platform[64];
	char email[64];
} password_t;

typedef struct node_s {
	password_t password_data;
	struct node_s *prev;
	struct node_s *next;
} node_t;

node_t *DB_HEAD = NULL;
int CURR_IDX = 0;

char LEN_CMD[] = "wc -l ../rsrc/passes.txt";
int IS_AUTHENTICATED = 0;
char *KEY = NULL;
int KEY_LEN = 0;

int count_lines() {
	FILE *f = popen(LEN_CMD, "r");
	int line_count = 0;
	fscanf(f, "%d", &line_count);
	fclose(f);
	return line_count;
}

void crypt(password_t *p, char *key) {
	for (int i = 0; i < strlen(p->password); i++) {
		p->password[i] = p->password[i] ^ key[i%KEY_LEN];
	}
}

void add_password(node_t **before_node, password_t *p) {
	node_t *current_node = malloc(sizeof(node_t));
	current_node->next = NULL;
	current_node->prev = *before_node;
	crypt(p, KEY);
	memcpy(&current_node->password_data, p, sizeof(password_t));
	if (*before_node == NULL) {
		*before_node = current_node;
		return;
	}
	current_node->next = (*before_node)->next;
	(*before_node)->next = current_node;
	return;
}

void unlock_password(node_t *current_node, char *key) {
	if (IS_AUTHENTICATED == 1) {
		crypt(&current_node->password_data, key);
	}
}

void init() {
	FILE *f = fopen("../rsrc/key.txt", "r");
	fseek(f, 0, SEEK_END);
	KEY_LEN = ftell(f);
	printf("%d\n", KEY_LEN);
	fseek(f, 0, SEEK_SET);
	KEY = calloc(KEY_LEN + 1, 1);
	fgets(KEY, KEY_LEN, f);
	fclose(f);
	f = fopen("../rsrc/passes.txt", "ra+");
	int line_count = count_lines();
	node_t **it = &DB_HEAD;
	for (int i = 0; i < line_count; i++) {
		password_t pass_data;
		fscanf(f, "%s %s %s\n", pass_data.platform, pass_data.password, pass_data.email);
		add_password(it, &pass_data);
	}
	fclose(f);

}

void interact() {
	node_t *it = DB_HEAD;
	unsigned int actions = 3;
	int *current_idx = &CURR_IDX;
	volatile long long size = 64;
	char buf[64];
	char cmd[16];
	while (actions > 0) {
		printf("> ");
		scanf("%s", cmd);
		if (!strncmp("NEXT", cmd, 16)) {
			(*current_idx)++; /* ADD GADGET */
			it = it->next;
		} else if (!strncmp("PREV", cmd, 16)) {
			(*current_idx)--; /* SUB GADGET */
			it = it->prev;
		} else if (!strncmp("PRINT", cmd, 16)) {
			printf("Current: %s\n", it->password_data.password); /* LOAD GADGET */
		} else if (!strncmp("WRITE", cmd, 16)) {
			fgets(buf, 64, stdin);
			memcpy(it->password_data.password, buf, size); /* STORE gadget */
		} else if (!strncmp("UNLOCK", cmd, 16)) {
			unlock_password(it, KEY);
		} else {
			printf("Unknown command: %s\n", cmd);
		}
		actions--;
	}
}

int main() {
	setvbuf(stdout, NULL, _IONBF, 0);
	init();
	node_t *it = DB_HEAD;
	while (it != NULL) {
		printf("%s %s %s\n", it->password_data.platform, it->password_data.password, it->password_data.email);
		it = it->next;
	}
	puts("AVAILABLE COMMANDS:");
	puts("NEXT");
	puts("PREV");
	puts("PRINT");
	puts("WRITE");
	puts("UNLOCK");
	interact();
	return 0;
}
